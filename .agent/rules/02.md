---
trigger: always_on
---

# Clipboard Brain — Architecture Specification

## 1. Purpose of This Document

This document defines:

- Application architectural pattern.
- Layer responsibilities.
- Dependency direction rules.
- State management strategy.
- Platform channel isolation.
- Folder organization rules.

Any deviation from this architecture is NOT allowed unless explicitly approved.

---

---

## 2. Architectural Pattern

The application follows a **Layered Architecture** inspired by Flutter best practices:

```

UI (Widgets)
↓
State (ChangeNotifier / ViewModels)
↓
Domain (Pure business logic)
↓
Infrastructure (Storage, Native APIs, AI, OS)

```

### Dependency Rule

Dependencies must flow strictly downward.

- UI can depend on State.
- State can depend on Domain.
- Domain can depend on nothing.
- Infrastructure can depend on Domain.

Reverse dependencies are NOT allowed.

---

---

## 3. State Management Strategy

### Technology

- `provider` package
- `ChangeNotifier` and `ValueNotifier`

### Rules

- Each screen has exactly one ViewModel.
- ViewModels extend `ChangeNotifier`.
- ViewModels expose:
  - Immutable public getters.
  - Explicit public commands (methods).
- UI never contains business logic.
- UI never directly accesses services or platform channels.
- No logic inside Widgets beyond rendering and event forwarding.

### Example Responsibility

| Layer          | Example               |
| -------------- | --------------------- |
| UI             | Button click          |
| ViewModel      | handleSearchChanged() |
| Domain         | Search algorithm      |
| Infrastructure | Database query        |

---

---

## 4. Domain Layer

### Responsibilities

Domain contains:

- Entities (ClipboardItem, Tag, SearchResult).
- Pure business logic.
- Validation rules.
- Filtering and ranking algorithms.

### Rules

- No Flutter imports.
- No platform APIs.
- No storage access.
- Fully testable.
- Stateless where possible.

---

---

## 5. Infrastructure Layer

### Responsibilities

Infrastructure contains:

- Local database access.
- File system access.
- Clipboard listeners (platform channels).
- AI model integration.
- Encryption.
- OS-level permissions.

### Rules

- Must implement interfaces defined in Domain or State.
- Must never expose platform details directly to UI.
- All native communication lives here.

---

---

## 6. Platform Channel Architecture

All native code access must go through:

```

Infrastructure
└── NativeBridgeService
└── MethodChannel / EventChannel
└── Swift Plugin

```

### Rules

- Only one NativeBridgeService exists.
- All method channel names are constants.
- No UI widgets call platform channels directly.
- Native exceptions must be translated into Dart-safe errors.

---

---

## 7. Folder Structure

```

lib/
├── app/
│     ├── app.dart
│     └── providers.dart
│
├── ui/
│     ├── main_window/
│     │      ├── main_window_page.dart
│     │      ├── main_window_view_model.dart
│     │      └── widgets/
│     │
│     ├── menu_bar/
│     ├── settings/
│     └── shared/
│
├── domain/
│     ├── entities/
│     ├── services/
│     └── value_objects/
│
├── infrastructure/
│     ├── database/
│     ├── clipboard/
│     ├── ai/
│     ├── security/
│     └── native_bridge/
│
└── main.dart

```

---

---

## 8. Data Flow Example

### Clipboard Event Flow

```

Swift Clipboard Listener
↓ EventChannel
NativeBridgeService
↓
ClipboardRepository (Infrastructure)
↓
ClipboardUseCase (Domain)
↓
MainWindowViewModel
↓
UI Update

```

---

---

## 9. Error Handling Strategy

### Rules

- Infrastructure throws typed exceptions.
- ViewModels catch and convert to UI state.
- UI only displays friendly messages.
- No raw stack traces shown to user.

---

---

## 10. Async Strategy

### Rules

- No blocking operations on UI thread.
- All IO must be async.
- Long AI processing must run in isolates if needed.
- ViewModels must expose loading states.

---

---

## 11. State Ownership Rules

- ViewModels own state.
- Domain is stateless.
- Infrastructure has no persistent state (except caches).

---

---

## 12. Dependency Injection Strategy

### Technique

- Manual dependency injection using constructors.
- Providers wired in `app/providers.dart`.

### Rules

- No service locator.
- No global static instances.

---

---

## 13. Testing Strategy (Future)

- Domain: unit tests.
- ViewModels: unit tests.
- Infrastructure: integration tests.
- UI: minimal widget tests.

---

---

## 14. Forbidden Practices

❌ Business logic inside Widgets  
❌ Platform channel calls in UI  
❌ Singletons  
❌ God classes  
❌ Direct database access from ViewModel  
❌ Circular dependencies  
❌ Static mutable state

---

---

## 15. Change Policy

Architecture changes require explicit approval.
